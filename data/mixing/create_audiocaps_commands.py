# This script parses the AudioCaps mix.csv file (generated by parsing the AudioCaps .csv using the script data/mixing/audiocaps_csv_mixer.py)
# and creates gramatically correct commands for the mixed audio clips, as well as their corresponding CLAP embeddings.
# an AudioCaps mix.csv file contains the following columns:
# ,audiocap_id_target,audiocap_id_interferer, youtube_id_target, youtube_id_interferer, start_time_target, start_time_interferer, caption_target, caption_interferer, caption_similarity
# The script will create a directory containing two files per mixed audio clip. One contains the embeddings in the .safetensors format.
# The other contains the command in the .json format, with the keys "command" and "type".

import argparse
import json
import os
import pandas as pd

from tqdm import trange

from commander import CommandCreator
from models.clap_encoder import CLAP_Encoder
from safetensors.torch import save_file


def create_commands(in_csv_path, out_dir_path, mode = "template"):
    """

    Args:
        in_csv_path (str): path to input mix.csv file
        out_dir_path (str): path to output directory where the commands will be saved
        mode (str, optional): "template" will construct the commands from available templates,
        followed by gramatical correction using deep learning. Conversely, "e2e" will ask a GPT to generate a command. Defaults to "template".
    """

    command_creator = CommandCreator(mode=mode, use_corrector=False)
    encoder = CLAP_Encoder().eval()

    os.makedirs(out_dir_path, exist_ok=True)

    df = pd.read_csv(in_csv_path)
    
    for i in trange(len(df)):
        row = df.iloc[i]
        target_caption = row['caption_target']
        interferer_caption = row['caption_interferer']

        command_text, command_type = command_creator(target_caption, [interferer_caption])
        command_embedding = encoder(text=[command_text], modality='text')[0]
        
        out_file_path = os.path.join(
            out_dir_path, f"{row['audiocap_id_target']}_{row['audiocap_id_interferer']}")

        # Save the command embedding and its text
        save_file( {
            'command': command_embedding,
        }, f"{out_file_path}.safetensors")

        with open(f"{out_file_path}.json", 'w') as f:
            json.dump({
                'command': command_text,
                'type': command_type
            }, f)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Create AudioCaps commands')
    parser.add_argument('--in_csv_dir', type=str, help='Path to input mix.csv files (train, val, test)')
    parser.add_argument('--out_dir', type=str, help='Path to output directory where the commands will be saved')
    parser.add_argument('--mode', type=str, default='template', help='Mode to create commands. Either "template" or "e2e"')
    args = parser.parse_args()

    for split in ['train', 'val', 'test']:
        in_csv_path = os.path.join(args.in_csv_dir, f"audiocaps_{split}_mix.csv")
        out_dir_path = os.path.join(args.out_dir, split)
        create_commands(in_csv_path, out_dir_path, mode=args.mode)
